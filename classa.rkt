#lang racket/gui
(provide (all-defined-out))
(require "classB.rkt");recuperation des classe des pt% et poly4%
(require "interface.rkt")
(require lang/posn)

(define SIZE 600)

(define segment%;definie par 2 point
  (class* object% (segment<%>)
    (init-field (a (new pt%)) (b (new pt%)) (visible #t))
    (define/public (get-a)
      a)
    (define/public (set-a! na);les set et getteur
      (set! a na))
    (define/public (get-b)
      b)
    (define/public (set-b! nb)
      (set! b nb))
    (define/public (set-visible! b)
      (set! visible b))
    (define/public (get-visible)
      visible)
    (define/public (get-vct);meme si cette classe ne possede pas de vecteur il est generer
      (new vecteur% (dx (- (send a get-x) (send b get-x))) (dy (- (send a get-y) (send b get-y)))))
    (define/public (affiche dc)
      (when visible
        (send dc set-pen SEG-PEN)
        (send dc draw-line (send a get-x) (send a get-y) (send b get-x) (send b get-y))))
    (define/public (force dc)
      (send dc set-pen FOR-PEN)
      (send dc draw-line (send a get-x) (send a get-y) (send b get-x) (send b get-y)))
    (super-new)))


(define droitePV%;classe des droite definie par un point et un vecteur
  (class* object% (droite<%>)
    (init-field (pt1 (new pt%)) (vct (new vecteur%)) (visible #t))
    (define/public (get-pt1)
      pt1)
    (define/public (set-pt1! npt)
      (set! pt1 npt))
    (define/public (get-vct)
      vct)
    (define/public (set-vct! nvct)
      (set! vct nvct))
    (define/public (set-visible! b)
      (set! visible b))
    (define/public (get-visible)
      visible)
    (define/public (get-pt2); meme si le pt2 ne fait pas partit de la class il est generer
      (new pt% (x (+ (send pt1 get-x) (* (send vct get-dx) 3))) (y (+ (send pt1 get-y) (* (send vct get-dy) 3)))))
    (define/public (get-eq);retourne un posn contenant l'equation du style ax+b=y
      (let* ((a (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000))) (/ (send vct get-dy) (send vct get-dx)))) 
             (b (- (send pt1 get-y) (* a (send pt1 get-x)))))
        (make-posn a b)))
    (define/public (affiche dc)
      (when visible
        (let* ((ls '())
               (eq (get-eq))
               (a (posn-x eq))
               (b (posn-y eq))
               (SIZE+10 (+ SIZE 10))
               (tmpx0 (new pt% (x 0) (y b)))
               (tmpy0 (new pt% (x (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000))) (/ (- b) a))) (y 0)))
               (tmpxSIZE (new pt% (x SIZE) (y (+ (* SIZE a) b))))
               (tmpySIZE (new pt% (x (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000))) (/ (- SIZE b) a))) (y SIZE))))
          (let ((dv (send tmpx0 get-y)))
            (when (and (< dv SIZE+10) (> dv -10))
              (set! ls (cons tmpx0 ls))))
          
          (let ((dv (send tmpxSIZE get-y)))
            (when (and (< dv SIZE+10) (> dv -10))
              (set! ls (cons tmpxSIZE ls))))
          
          (let ((dv (send tmpy0 get-x)))
            (when (and (< dv SIZE+10) (> dv -10))
              (set! ls (cons tmpy0 ls))))
          
          (let ((dv (send tmpySIZE get-x)))
            (when (and (< dv SIZE+10) (> dv -10))
              (set! ls (cons tmpySIZE ls))))
          (when (>= (length ls) 2)
            (send dc set-pen SEG-PEN)
            (send dc draw-line (send (car ls) get-x) (send (car ls) get-y) (send (cadr ls) get-x) (send (cadr ls) get-y)))
          (set! ls (cdr ls))
          (when (>= (length ls) 2)
            (send dc draw-line (send (car ls) get-x) (send (car ls) get-y) (send (cadr ls) get-x) (send (cadr ls) get-y))))))
    (define/public (force dc)
      (let* ((ls '())
             (eq (get-eq))
             (a (posn-x eq))
             (b (posn-y eq))
             (SIZE+10 (+ SIZE 10))
             (tmpx0 (new pt% (x 0) (y b)))
             (tmpy0 (new pt% (x (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000))) (/ (- b) a))) (y 0)))
             (tmpxSIZE (new pt% (x SIZE) (y (+ (* SIZE a) b))))
             (tmpySIZE (new pt% (x (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000))) (/ (- SIZE b) a))) (y SIZE))))
        (let ((dv (send tmpx0 get-y)))
          (when (and (< dv SIZE+10) (> dv -10))
            (set! ls (cons tmpx0 ls))))
        
        (let ((dv (send tmpxSIZE get-y)))
          (when (and (< dv SIZE+10) (> dv -10))
            (set! ls (cons tmpxSIZE ls))))
        
        (let ((dv (send tmpy0 get-x)))
          (when (and (< dv SIZE+10) (> dv -10))
            (set! ls (cons tmpy0 ls))))
        
        (let ((dv (send tmpySIZE get-x)))
          (when (and (< dv SIZE+10) (> dv -10))
            (set! ls (cons tmpySIZE ls))))
        (when (>= (length ls) 2)
          (send dc set-pen SEG-PEN)
          (send dc draw-line (send (car ls) get-x) (send (car ls) get-y) (send (cadr ls) get-x) (send (cadr ls) get-y)))
        (set! ls (cdr ls))
        (when (>= (length ls) 2)
          (send dc draw-line (send (car ls) get-x) (send (car ls) get-y) (send (cadr ls) get-x) (send (cadr ls) get-y)))))
    (super-new)))

(define droite2P% ;classe des droite definie par 2 points distinct
  (class* object% (droite<%>)
    (init-field (pt1 (new pt%)) (pt2 (new pt%)) (visible #t))
    (define/public (get-pt1)
      pt1)
    (define/public (set-pt1! npt)
      (set! pt1 npt))
    (define/public (get-pt2)
      pt2)
    (define/public (set-pt2! npt)
      (set! pt2 npt))
    (define/public (set-visible! b)
      (set! visible b))
    (define/public (get-visible)
      visible)
    (define/public (get-vct);meme si cette classe ne possede pas de vecteur il est generer
      (new vecteur% (dx (- (send pt1 get-x) (send pt2 get-x))) (dy (- (send pt1 get-y) (send pt2 get-y)))))
    (define/public (get-eq);retourne un posn contenant l'equation du style ax+b=y
      (let* ((vct (get-vct)) 
             (a (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000))) (/ (send vct get-dy) (send vct get-dx)))) 
             (b (- (send pt1 get-y) (* a (send pt1 get-x)))))
        (make-posn a b)));au dessus le 8000 pour bluffer 
    (define/public (affiche dc)
      (when visible
        (let* ((ls '())
               (eq (get-eq))
               (a (posn-x eq))
               (b (posn-y eq))
               (tmpx0 (new pt% (x 0) (y b)))
               (tmpy0 (new pt% (x (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000))) (/ (- b) a))) (y 0)))
               (tmpxSIZE (new pt% (x SIZE) (y (+ (* SIZE a) b))))
               (tmpySIZE (new pt% (x (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000))) (/ (- SIZE b) a))) (y SIZE)))
               (SIZE+10 (+ SIZE 10))
               )
          (let ((dv (send tmpx0 get-y)))
            (when (and (< dv SIZE+10) (> dv -10))
              (set! ls (cons tmpx0 ls))))
          
          (let ((dv (send tmpxSIZE get-y)))
            (when (and (< dv SIZE+10) (> dv -10))
              (set! ls (cons tmpxSIZE ls))))
          
          (let ((dv (send tmpy0 get-x)))
            (when (and (< dv SIZE+10) (> dv -10))
              (set! ls (cons tmpy0 ls))))
          
          (let ((dv (send tmpySIZE get-x)))
            (when (and (< dv SIZE+10) (> dv -10))
              (set! ls (cons tmpySIZE ls))))
          (when (>= (length ls) 2)
            (send dc set-pen SEG-PEN)
            (send dc draw-line (send (car ls) get-x) (send (car ls) get-y) (send (cadr ls) get-x) (send (cadr ls) get-y)))
          (set! ls (cdr ls))
          (when (>= (length ls) 2)
            (send dc draw-line (send (car ls) get-x) (send (car ls) get-y) (send (cadr ls) get-x) (send (cadr ls) get-y)))
          )))
    
    (define/public (force dc)
      (let* ((ls '())
             (eq (get-eq))
             (a (posn-x eq))
             (b (posn-y eq))
             (SIZE+10 (+ SIZE 10))
             (tmpx0 (new pt% (x 0) (y b)))
             (tmpy0 (new pt% (x (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000))) (/ (- b) a))) (y 0)))
             (tmpxSIZE (new pt% (x SIZE) (y (+ (* SIZE a) b))))
             (tmpySIZE (new pt% (x (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000))) (/ (- SIZE b) a))) (y SIZE))))
        (let ((dv (send tmpx0 get-y)))
          (when (and (< dv SIZE+10) (> dv -10))
            (set! ls (cons tmpx0 ls))))
        
        (let ((dv (send tmpxSIZE get-y)))
          (when (and (< dv SIZE+10) (> dv -10))
            (set! ls (cons tmpxSIZE ls))))
        
        (let ((dv (send tmpy0 get-x)))
          (when (and (< dv SIZE+10) (> dv -10))
            (set! ls (cons tmpy0 ls))))
        
        (let ((dv (send tmpySIZE get-x)))
          (when (and (< dv SIZE+10) (> dv -10))
            (set! ls (cons tmpySIZE ls))))
        (when (>= (length ls) 2)
          (send dc set-pen SEG-PEN)
          (send dc draw-line (send (car ls) get-x) (send (car ls) get-y) (send (cadr ls) get-x) (send (cadr ls) get-y)))
        (set! ls (cdr ls))
          (when (>= (length ls) 2)
            (send dc draw-line (send (car ls) get-x) (send (car ls) get-y) (send (cadr ls) get-x) (send (cadr ls) get-y)))))
    (super-new)))

;formule des produit scalaire : http://paquito.amposta.free.fr/glossp/prodscal.htm
;on trouve une vecteur normal grace au produit scalaire null
(define droiteM% ;classe des droite definie par 1 segment et qui est sa mediatrice
  (class* object% (droite<%>)
    (init-field (S (new segment%))(visible #t))
    (define/public (get-pt1)
      (milieu))
    (define/public (set-visible! b)
      (set! visible b))
    (define/public (get-visible)
      visible)
    (define (milieu)
      (new pt% 
           (x (/ (+ (send (send S get-a) get-x) (send (send S get-b) get-x)) 2))
           (y (/ (+ (send (send S get-a) get-y) (send (send S get-b) get-y)) 2))))
    (define/public (get-pt2)
      (let ((p (get-pt1)) (vct (get-vct)))
        (new pt% (x (+ (send p get-x) (send vct get-dx))) (y (+ (send p get-y) (send vct get-dy))))))
    (define/public (get-vct);meme si cette classe ne possede pas de vecteur il est generer
      (let* ((vctS (send S get-vct))
             (vctdy (send vctS get-dy)))
        (if (= 0 vctdy)
            (new vecteur% (dx 10) (dy 8000))
            (new vecteur% (dx 10) (dy (- (/ (* 10 (send vctS get-dx)) (send vctS get-dy))))))))
    (define/public (get-eq);retourne un posn contenant l'equation du style ax+b=y
      (let* ((pt1 (get-pt1))
             (vct (get-vct))
             (a (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000)))  (/ (send vct get-dy) (send vct get-dx))))
             (b (- (send pt1 get-y) (* a (send pt1 get-x)))))
        (make-posn a b)));au dessus le 8000 pour bluffer 
    (define/public (affiche dc)
      (when visible
        (let* ((ls '())
               (eq (get-eq))
               (a (posn-x eq))
               (b (posn-y eq))
               (SIZE+10 (+ SIZE 10))
               (tmpx0 (new pt% (x 0) (y b)))
               (tmpy0 (new pt% (x (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000))) (/ (- b) a))) (y 0)))
               (tmpxSIZE (new pt% (x SIZE) (y (+ (* SIZE a) b))))
               (tmpySIZE (new pt% (x (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000))) (/ (- SIZE b) a))) (y SIZE))))
          (let ((dv (send tmpx0 get-y)))
            (when (and (< dv SIZE+10) (> dv -10))
              (set! ls (cons tmpx0 ls))))
          
          (let ((dv (send tmpxSIZE get-y)))
            (when (and (< dv SIZE+10) (> dv -10))
              (set! ls (cons tmpxSIZE ls))))
          
          (let ((dv (send tmpy0 get-x)))
            (when (and (< dv SIZE+10) (> dv -10))
              (set! ls (cons tmpy0 ls))))
          
          (let ((dv (send tmpySIZE get-x)))
            (when (and (< dv SIZE+10) (> dv -10))
              (set! ls (cons tmpySIZE ls))))
          (when (>= (length ls) 2)
            (send dc set-pen SEG-PEN)
            (send dc draw-line (send (car ls) get-x) (send (car ls) get-y) (send (cadr ls) get-x) (send (cadr ls) get-y)))
          (set! ls (cdr ls))
          (when (>= (length ls) 2)
            (send dc draw-line (send (car ls) get-x) (send (car ls) get-y) (send (cadr ls) get-x) (send (cadr ls) get-y))))))
    (define/public (force dc)
      (let* ((ls '())
             (eq (get-eq))
             (a (posn-x eq))
             (b (posn-y eq))
             (SIZE+10 (+ SIZE 10))
             (tmpx0 (new pt% (x 0) (y b)))
             (tmpy0 (new pt% (x (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000))) (/ (- b) a))) (y 0)))
             (tmpxSIZE (new pt% (x SIZE) (y (+ (* SIZE a) b))))
             (tmpySIZE (new pt% (x (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000))) (/ (- SIZE b) a))) (y SIZE))))
        (let ((dv (send tmpx0 get-y)))
          (when (and (< dv SIZE+10) (> dv -10))
            (set! ls (cons tmpx0 ls))))
        
        (let ((dv (send tmpxSIZE get-y)))
          (when (and (< dv SIZE+10) (> dv -10))
            (set! ls (cons tmpxSIZE ls))))
        
        (let ((dv (send tmpy0 get-x)))
          (when (and (< dv SIZE+10) (> dv -10))
            (set! ls (cons tmpy0 ls))))
        
        (let ((dv (send tmpySIZE get-x)))
          (when (and (< dv SIZE+10) (> dv -10))
            (set! ls (cons tmpySIZE ls))))
        (when (>= (length ls) 2)
          (send dc set-pen SEG-PEN)
          (send dc draw-line (send (car ls) get-x) (send (car ls) get-y) (send (cadr ls) get-x) (send (cadr ls) get-y)))
        (set! ls (cdr ls))
          (when (>= (length ls) 2)
            (send dc draw-line (send (car ls) get-x) (send (car ls) get-y) (send (cadr ls) get-x) (send (cadr ls) get-y)))))
    (super-new)))

(define droitePAR% ;classe des droite parallele a une autre droite passant par un point
  (class* object% (droite<%>)
    (init-field (pt1 (new pt%)) (D (new droitePV%)) (visible #t))
    (define/public (get-pt1)
      pt1)
    (define/public (set-pt1! p)
      (set! pt1 p))
    (define/public (set-visible! b)
      (set! visible b))
    (define/public (get-visible)
      visible)
    (define/public (get-pt2)
      (let ((p (get-pt1)) (vct (get-vct)))
        (new pt% (x (+ (send p get-x) (send vct get-dx))) (y (+ (send p get-y) (send vct get-dy))))))
    (define/public (get-vct);meme si cette classe ne possede pas de vecteur il est generer
      (send D get-vct))
    (define/public (get-eq);retourne un posn contenant l'equation du style ax+b=y
      (let* ((vct (get-vct))
             (a (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000)))  (/ (send vct get-dy) (send vct get-dx))))
             (b (- (send pt1 get-y) (* a (send pt1 get-x)))))
        (make-posn a b)))
    (define/public (affiche dc)
      (when visible
        (let* ((ls '())
               (eq (get-eq))
               (a (posn-x eq))
               (b (posn-y eq))
               (SIZE+10 (+ SIZE 10))
               (tmpx0 (new pt% (x 0) (y b)))
               (tmpy0 (new pt% (x (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000))) (/ (- b) a))) (y 0)))
               (tmpxSIZE (new pt% (x SIZE) (y (+ (* SIZE a) b))))
               (tmpySIZE (new pt% (x (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000))) (/ (- SIZE b) a))) (y SIZE))))
          (let ((dv (send tmpx0 get-y)))
            (when (and (< dv SIZE+10) (> dv -10))
              (set! ls (cons tmpx0 ls))))
          
          (let ((dv (send tmpxSIZE get-y)))
            (when (and (< dv SIZE+10) (> dv -10))
              (set! ls (cons tmpxSIZE ls))))
          
          (let ((dv (send tmpy0 get-x)))
            (when (and (< dv SIZE+10) (> dv -10))
              (set! ls (cons tmpy0 ls))))
          
          (let ((dv (send tmpySIZE get-x)))
            (when (and (< dv SIZE+10) (> dv -10))
              (set! ls (cons tmpySIZE ls))))
          (when (>= (length ls) 2)
            (send dc set-pen SEG-PEN)
            (send dc draw-line (send (car ls) get-x) (send (car ls) get-y) (send (cadr ls) get-x) (send (cadr ls) get-y)))
          (set! ls (cdr ls))
          (when (>= (length ls) 2)
            (send dc draw-line (send (car ls) get-x) (send (car ls) get-y) (send (cadr ls) get-x) (send (cadr ls) get-y))))))
    (define/public (force dc)
      (let* ((ls '())
             (eq (get-eq))
             (a (posn-x eq))
             (b (posn-y eq))
             (SIZE+10 (+ SIZE 10))
             (tmpx0 (new pt% (x 0) (y b)))
             (tmpy0 (new pt% (x (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000))) (/ (- b) a))) (y 0)))
             (tmpxSIZE (new pt% (x SIZE) (y (+ (* SIZE a) b))))
             (tmpySIZE (new pt% (x (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000))) (/ (- SIZE b) a))) (y SIZE))))
        (let ((dv (send tmpx0 get-y)))
          (when (and (< dv SIZE+10) (> dv -10))
            (set! ls (cons tmpx0 ls))))
        
        (let ((dv (send tmpxSIZE get-y)))
          (when (and (< dv SIZE+10) (> dv -10))
            (set! ls (cons tmpxSIZE ls))))
        
        (let ((dv (send tmpy0 get-x)))
          (when (and (< dv SIZE+10) (> dv -10))
            (set! ls (cons tmpy0 ls))))
        
        (let ((dv (send tmpySIZE get-x)))
          (when (and (< dv SIZE+10) (> dv -10))
            (set! ls (cons tmpySIZE ls))))
        (when (>= (length ls) 2)
          (send dc set-pen SEG-PEN)
          (send dc draw-line (send (car ls) get-x) (send (car ls) get-y) (send (cadr ls) get-x) (send (cadr ls) get-y)))
        (set! ls (cdr ls))
          (when (>= (length ls) 2)
            (send dc draw-line (send (car ls) get-x) (send (car ls) get-y) (send (cadr ls) get-x) (send (cadr ls) get-y)))))
    (super-new)))

(define droitePER%;classe des droites perpendiculaire à une autre droite
  (class* object% (droite<%>)
    (init-field (pt1 (new pt%)) (D (new droitePV%)) (visible #t))
    (define/public (get-pt1)
      pt1)
    (define/public (set-pt1! p)
      (set! pt1 p))
    (define/public (get-vct);meme si cette classe ne possede pas de vecteur il est generer
      (let* ((vctS (send D get-vct))
             (vctdy (send vctS get-dy)))
        (if (= 0 vctdy)
            (new vecteur% (dx 10) (dy 8000))
            (new vecteur% (dx 10) (dy (- (/ (* 10 (send vctS get-dx)) (send vctS get-dy))))))))
    (define/public (get-eq);retourne un posn contenant l'equation du style ax+b=y
      (let* ((vct (get-vct))
             (a (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000))) (/ (send vct get-dy) (send vct get-dx))))
             (b (- (send pt1 get-y) (* a (send pt1 get-x)))))
        (make-posn a b)))
    (define/public (set-visible! b)
      (set! visible b))
    (define/public (get-visible)
      visible)
    (define/public (affiche dc)
      (when visible
        (let* ((ls '())
               (eq (get-eq))
               (a (posn-x eq))
               (b (posn-y eq))
               (SIZE+10 (+ SIZE 10))
               (tmpx0 (new pt% (x 0) (y b)))
               (tmpy0 (new pt% (x (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000))) (/ (- b) a))) (y 0)))
               (tmpxSIZE (new pt% (x SIZE) (y (+ (* SIZE a) b))))
               (tmpySIZE (new pt% (x (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000))) (/ (- SIZE b) a))) (y SIZE))))
          (let ((dv (send tmpx0 get-y)))
            (when (and (< dv SIZE+10) (> dv -10))
              (set! ls (cons tmpx0 ls))))
          
          (let ((dv (send tmpxSIZE get-y)))
            (when (and (< dv SIZE+10) (> dv -10))
              (set! ls (cons tmpxSIZE ls))))
          
          (let ((dv (send tmpy0 get-x)))
            (when (and (< dv SIZE+10) (> dv -10))
              (set! ls (cons tmpy0 ls))))
          
          (let ((dv (send tmpySIZE get-x)))
            (when (and (< dv SIZE+10) (> dv -10))
              (set! ls (cons tmpySIZE ls))))
          (when (>= (length ls) 2)
            (send dc set-pen SEG-PEN)
            (send dc draw-line (send (car ls) get-x) (send (car ls) get-y) (send (cadr ls) get-x) (send (cadr ls) get-y)))
          (set! ls (cdr ls))
          (when (>= (length ls) 2)
            (send dc draw-line (send (car ls) get-x) (send (car ls) get-y) (send (cadr ls) get-x) (send (cadr ls) get-y))))))
    (define/public (force dc)
      (let* ((ls '())
             (eq (get-eq))
             (a (posn-x eq))
             (b (posn-y eq))
             (SIZE+10 (+ SIZE 10))
             (tmpx0 (new pt% (x 0) (y b)))
             (tmpy0 (new pt% (x (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000))) (/ (- b) a))) (y 0)))
             (tmpxSIZE (new pt% (x SIZE) (y (+ (* SIZE a) b))))
             (tmpySIZE (new pt% (x (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000))) (/ (- SIZE b) a))) (y SIZE))))
        (let ((dv (send tmpx0 get-y)))
          (when (and (< dv SIZE+10) (> dv -10))
            (set! ls (cons tmpx0 ls))))
        
        (let ((dv (send tmpxSIZE get-y)))
          (when (and (< dv SIZE+10) (> dv -10))
            (set! ls (cons tmpxSIZE ls))))
        
        (let ((dv (send tmpy0 get-x)))
          (when (and (< dv SIZE+10) (> dv -10))
            (set! ls (cons tmpy0 ls))))
        
        (let ((dv (send tmpySIZE get-x)))
          (when (and (< dv SIZE+10) (> dv -10))
            (set! ls (cons tmpySIZE ls))))
        (when (>= (length ls) 2)
          (send dc set-pen SEG-PEN)
          (send dc draw-line (send (car ls) get-x) (send (car ls) get-y) (send (cadr ls) get-x) (send (cadr ls) get-y)))
        (set! ls (cdr ls))
          (when (>= (length ls) 2)
            (send dc draw-line (send (car ls) get-x) (send (car ls) get-y) (send (cadr ls) get-x) (send (cadr ls) get-y)))))
    (super-new)))

(define ptI2D%;class des point d'intersection de deux droite pour qu'il garde leur pointeur et se modifie seul !
  (class* object% (point<%>)
    (init-field (d1 (new droitePV%))(d2 (new droitePV%))(visible #t))
    (define/public (get-x)
      (let* ((eqD1 (send d1 get-eq))
             (eqD2 (send d2 get-eq))
             (x1-x2 (- (posn-x eqD1) (posn-x eqD2))))
        (if (= 0 x1-x2);pour evité une division par zero on bluff !
            8000
            (/ (- (posn-y eqD2) (posn-y eqD1)) x1-x2))))
    (define/public (get-y)
      (let* ((eqD1 (send d1 get-eq))
             (eqD2 (send d2 get-eq))
             (X (get-x));on recupere x pour eviter qu'il y est de div par 0
             (Y (+ (* (posn-x eqD1) X) (posn-y eqD1))))
        Y))
    (define/public (get-visible)
      visible)
    (define/public (set-visible! nvisible)
      (set! visible nvisible))
    (define/public (egal? p)
      (and (= (get-x) (send p get-x)) (= (get-y) (send p get-y))))
    (define/public (affiche dc);la fonction affiche commune a tout les objets qui seront créé qui affiche uniquement si visible!
      (when visible
        (let* ((eqD1 (send d1 get-eq))
               (eqD2 (send d2 get-eq))
               (x (with-handlers ((exn:fail:contract:divide-by-zero? (lambda (e) 8000))) (/ (- (posn-y eqD2) (posn-y eqD1)) (- (posn-x eqD1) (posn-x eqD2)))))
               (y (+ (* (posn-x eqD1) x) (posn-y eqD1))))
          (send dc set-pen POINTI2D-PEN)
          (send dc draw-line (- x 2) (- y 2) (+ x 2) (+ y 2))
          (send dc draw-line (- x 2) (+ y 2) (+ x 2) (- y 2))
          (send dc draw-point x y))))
    (super-new)))

(define ptMS%;class des point milieu d'un segment
  (class* object% (point<%>)
    (init-field (S (new segment%))(visible #t))
    (define/public (get-x)
      (/ (+ (send (send S get-a) get-x) (send (send S get-b) get-x)) 2))
    (define/public (get-y)
      (/ (+ (send (send S get-a) get-y) (send (send S get-b) get-y)) 2))
    (define/public (get-visible)
      visible)
    (define/public (set-visible! nvisible)
      (set! visible nvisible))
    (define/public (set-x! x);on offre ces fausse fonction pour eviter qu'il ne sois grossier
      x)
    (define/public (set-y! y)
      y)
    (define/public (egal? p)
      (and (= (get-x) (send p get-x)) (= (get-y) (send p get-y))))
    (define/public (affiche dc);la fonction affiche commune a tout les objets qui seront créé qui affiche uniquement si visible!
      (when visible
        (let* ((x (get-x))
               (y (get-y)))
          (send dc set-pen POINT-PEN)
          (send dc draw-line (- x 2) (- y 2) (+ x 2) (+ y 2))
          (send dc draw-line (- x 2) (+ y 2) (+ x 2) (- y 2))
          (send dc draw-point x y))))
    (super-new)))